require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe "Tags API", type: :request do
  let!(:user) { FactoryBot.create(:user) }
  let!(:example_tag) { FactoryBot.create(:tag, user: user) }

  let!(:headers) {
    post '/login', params: { user: { email: user.email, password: user.password } }, headers: { 'ACCEPT' => 'application/json' }
    token = response.headers['Authorization'].split(" ").last
    { 'Content-Type'=> 'application/json', 'Authorization' => "Bearer #{token}" }
  }

  let(:bad_headers) {
    { 'Content-Type'=> 'application/json', 'Authorization' => "Bearer deaniilfaefjiaedp120d13" }
  }

  describe "GET /tags" do
    it "Returns a list of tags with valid request" do
      get '/tags', headers: headers
      # Ensure we are returning the correct status code
      expect(response).to be_successful
      expect(response).to have_http_status(:ok)

      # Ensure the returned list contains our example tag (as it should)
      response_data = JSON.parse(response.body)
      expect(response_data['data'][0]['attributes']['tag_name']).to eq(example_tag.tag_name)
      expect(response_data['data'][0]['attributes']['description']).to eq(example_tag.description)
    end

    it 'Returns a 401 (unauthorized) with invalid token' do
      get '/tags', headers: bad_headers
      expect(response).to_not be_successful
      expect(response).to have_http_status(:unauthorized)
    end
  end

  describe "GET /tags/:id" do
    let(:showRoute) { "/tags/#{example_tag.id}" }
    it "Returns the tag upon valid request" do
      get showRoute, headers: headers
      # Ensure the correct status code is returned
      expect(response).to have_http_status(:ok)
      # Ensure the returned object contains our example tag fields
      response_data = JSON.parse(response.body)
      expect(response_data['data']['id']).to eq(example_tag.id.to_s)
      expect(response_data['data']['attributes']['tag_name']).to eq(example_tag.tag_name)
      expect(response_data['data']['attributes']['description']).to eq(example_tag.description)
    end

    it "Returns a 404 (not found) error if the tag does not exist" do
      get '/tags/99999', headers: headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:not_found)
    end

    it "Returns a 401 (unauthorized) error with invalid token" do
      get showRoute, headers: bad_headers

      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:unauthorized)
    end
  end

  describe "POST /tags" do
    let!(:createParams) { { tag: { tag_name: 'Post Example Tag', description: 'Tag Post Example Description', color: 'Red' } } }

    it "Returns a new tag with valid request" do
      post '/tags', params: createParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to be_successful
      expect(response).to have_http_status(:created)
      # Check the user has saved the new tag
      user.reload
      new_tag = user.tags.find_by(tag_name: 'Post Example Tag')
      expect(new_tag).to_not be_nil
      # Make sure the fields match what we expect
      expect(new_tag.tag_name).to eq('Post Example Tag')
      expect(new_tag.description).to eq('Tag Post Example Description')
      expect(new_tag.color).to eq('Red')
    end

    it 'Returns a 401 (unauthorized) error with invalid token' do
      post '/tags', params: createParams.to_json, headers: bad_headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:unauthorized)
    end

    it 'Returns a 422 (unprocessable entity) error when creating a tag with duplicate tag_name' do
      duplicateCreateParams = { tag: { tag_name: example_tag.tag_name, description: example_tag.description, color: example_tag.color } }
      post '/tags', params: duplicateCreateParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:unprocessable_entity)
      # Check error message
      response_data = JSON.parse(response.body)
      expect(response_data['error']).to eq({ "tag_name" => [ 'should be unique within the scope of the user' ] })
    end

    it 'Returns a 400 (bad request) error when trying to feed non-permitted parameters' do
      badCreateParams = { tag2: { tag_name: 'Post Example Tag', description: 'Tag Post Example Description', color: 'Red' } }
      post '/tags', params: badCreateParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:bad_request)
    end
  end

  describe "PATCH /tags" do
    let!(:updateParams) { { tag: { id: example_tag.id } } }

    it 'Updates a tag with valid request' do
      # Create update params (for a new name)
      updateParams[:tag][:tag_name] = 'Patch Example Tag'
      updateParams[:tag][:description] = 'Patch Example Description'
      updateParams[:tag][:color] = 'Patch Example Color'

      patch '/tags', params: updateParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to be_successful
      expect(response).to have_http_status(:ok)
      # Check that the tag was correctly updated
      example_tag.reload
      response_data = JSON.parse(response.body)
      expect(response_data['data']['id']).to eq(example_tag.id.to_s)
      expect(response_data['data']['attributes']['tag_name']).to eq(example_tag.tag_name)
      expect(response_data['data']['attributes']['description']).to eq(example_tag.description)
      expect(response_data['data']['attributes']['color']).to eq(example_tag.color)
    end

    it 'Returns a 401 (unauthorized) error with invalid token' do
      patch '/tags', params: updateParams.to_json, headers: bad_headers
      expect(response).to_not be_successful
      expect(response).to have_http_status(:unauthorized)
    end

    it 'Returns a 404 (not found error) if tag does not exist' do
      updateParams[:tag][:id] = 99999999
      patch '/tags', params: updateParams.to_json, headers: headers
      expect(response).to_not be_successful
      expect(response).to have_http_status(:not_found)
    end

    it 'Returns a 422 (unprocessable entity) if tag attempts to change name to existing tag name' do
      # Create a new tag in the database (ensure the tag name is unique by appending on other tag)
      user.reload
      new_tag = user.tags.create!({ tag_name: "#{example_tag.tag_name}2", description: 'Patch duplicate tag name change description', color: 'Blue' })
      new_tag.reload
      expect(new_tag).not_to be_nil
      # Request to change new tags name to the original example tag
      updateParams[:tag][:tag_name] = new_tag.tag_name
      patch '/tags', params: updateParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:unprocessable_entity)
    end
  end

  describe "DELETE /tags" do
    let!(:deleteParams) { { tag: { id: example_tag.id } } }

    it "Deletes the example tag with valid request" do
      # Make sure the example tag exists in the database
      expect(Tag.exists?(example_tag.id)).to be true
      # Send the delete request
      delete '/tags', params: deleteParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to be_successful
      expect(response).to have_http_status(:ok)
      # Check the object was successfully destroyed
      expect(Tag.exists?(example_tag.id)).to be false
    end

    it "Returns a 401 (unauthorized) error with invalid token" do
      delete '/tags', params: deleteParams.to_json, headers: bad_headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:unauthorized)
    end

    it "Returns a 404 (not found) error if tag does not exist" do
      # Assign a non-existing tag name to the delete parameters
      deleteParams[:tag][:id] = 999999
      delete '/tags', params: deleteParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:not_found)
    end

    it "Returns a 400 (bad request) error with invalid parameters" do
      badDeleteParams = { not_tag: { tag_name: example_tag.tag_name } }
      delete '/tags', params: badDeleteParams.to_json, headers: headers
      # Ensure correct response status code
      expect(response).to_not be_successful
      expect(response).to have_http_status(:bad_request)
    end
  end
end
